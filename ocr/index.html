<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
		<title>ATM Slip OCR</title>
		<script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.2/dist/tesseract.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
		<link href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css" rel="stylesheet" />
		<script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>

		<style>
			body {
				font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
				padding: 1rem;
				margin: 0;
				background: #f0f2f5;
				color: #333;
				line-height: 1.6;
			}
			.container {
				max-width: 700px;
				margin: 0 auto;
				background: #fff;
				padding: 1.5rem;
				border-radius: 8px;
				box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
			}
			h2 {
				text-align: center;
				color: #007bff;
				margin-top: 0;
				margin-bottom: 1.5rem;
			}
			.input-options {
				display: flex;
				flex-direction: column;
				gap: 0.75rem;
				margin-bottom: 1.5rem;
			}
			button,
			input[type="button"] {
				display: block;
				width: 100%;
				margin: 0.5rem auto;
				padding: 0.85rem 1.5rem;
				font-size: 1rem;
				font-weight: 500;
				background: #007bff;
				color: white;
				border: none;
				border-radius: 6px;
				cursor: pointer;
				transition: background-color 0.2s ease;
			}
			button#extractBtn {
				background-color: #28a745;
			}
			button#extractBtn:hover:not(:disabled) {
				background-color: #1e7e34;
			}
			button:hover:not(:disabled),
			input[type="button"]:hover:not(:disabled) {
				background: #0056b3;
			}
			button:disabled,
			input[type="button"]:disabled {
				background: #cccccc;
				cursor: not-allowed;
			}
			label.file-input-button {
				display: block;
				padding: 0.85rem 1.5rem;
				background-color: #6c757d;
				color: white;
				border-radius: 6px;
				text-align: center;
				cursor: pointer;
				font-size: 1rem;
				font-weight: 500;
				width: 100%;
				box-sizing: border-box;
				transition: background-color 0.2s ease;
			}
			label.file-input-button:hover {
				background-color: #5a6268;
			}
			img#preview,
			img#cropPreviewImage {
				max-width: 100%;
				max-height: 300px;
				object-fit: contain;
				display: block;
				margin: 1rem auto;
				border: 1px solid #eee;
				border-radius: 8px;
				background-color: #f9f9f9;
			}
			.crop-modal {
				display: none;
				position: fixed;
				z-index: 1000;
				left: 0;
				top: 0;
				width: 100%;
				height: 100%;
				overflow: auto;
				background-color: rgba(0, 0, 0, 0.6);
				align-items: center;
				justify-content: center;
				flex-direction: column;
			}
			.crop-modal-content {
				background-color: #fefefe;
				margin: auto;
				padding: 20px;
				border: 1px solid #888;
				width: 90%;
				max-width: 600px;
				border-radius: 8px;
				box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
				display: flex;
				flex-direction: column;
			}
			#cropImageContainer {
				width: 100%;
				height: 60vh;
				max-height: 400px;
				margin-bottom: 15px;
				overflow: hidden;
			}
			#cropImageContainer img {
				display: block;
				max-width: 100%;
			}
			.crop-actions {
				margin-top: 15px;
				text-align: center;
				display: flex;
				justify-content: space-around;
			}
			.crop-actions button {
				width: auto;
				min-width: 100px;
				margin: 0 5px;
				display: inline-block;
			}

			#enhancementControls {
				margin-top: 1rem;
				padding: 1rem;
				border: 1px solid #ddd;
				border-radius: 6px;
				background-color: #f9f9f9;
			}
			#enhancementControls h3 {
				margin-top: 0;
				text-align: center;
				color: #333;
			}
			#enhancementControls label {
				display: block;
				margin: 0.75rem 0 0.25rem 0;
				font-size: 0.9em;
			}
			#enhancementControls input[type="range"] {
				width: 100%;
			}
			#enhancementControls .slider-value {
				font-weight: bold;
				margin-left: 10px;
			}

			.result-table {
				max-width: 100%;
				margin: 1.5rem auto;
				overflow-x: auto;
			}
			table {
				width: 100%;
				border-collapse: collapse;
			}
			th,
			td {
				padding: 0.6rem 0.5rem;
				text-align: center;
				border: 1px solid #e0e0e0;
			}
			th {
				background-color: #f8f9fa;
				font-weight: 500;
			}
			input[type="text"] {
				width: 100%;
				padding: 0.4rem;
				text-align: center;
				border: 1px solid #ccc;
				border-radius: 4px;
				box-sizing: border-box;
				font-size: 0.9rem;
				transition: background-color 0.2s ease;
			}
			input[type="text"].col-invalid {
				background-color: #ffcccc !important;
				border-color: #ff9999 !important;
			}
			input[type="text"].field-problem {
				background-color: #fff2f2 !important;
			}
			pre#rawText {
				white-space: pre-wrap;
				word-wrap: break-word;
				padding: 1rem;
				background: #f5f5f5;
				border: 1px solid #ccc;
				border-radius: 6px;
				margin-top: 1.5rem;
				font-size: 0.85em;
				max-height: 200px;
				overflow-y: auto;
			}
			#progressIndicator {
				text-align: center;
				margin: 1.5rem 0;
				padding: 1rem;
				background-color: #f9f9f9;
				border-radius: 6px;
			}
			.spinner {
				border: 4px solid rgba(0, 0, 0, 0.1);
				width: 30px;
				height: 30px;
				border-radius: 50%;
				border-left-color: #007bff;
				animation: spin 1s ease infinite;
				margin: 0 auto 0.5rem auto;
			}
			@keyframes spin {
				0% {
					transform: rotate(0deg);
				}
				100% {
					transform: rotate(360deg);
				}
			}
			#progressMessage {
				margin-top: 0.5rem;
				font-size: 0.95rem;
				color: #333;
			}
			#progressBarContainer {
				width: 90%;
				margin: 0.75rem auto 0 auto;
				background-color: #e0e0e0;
				border-radius: 4px;
				overflow: hidden;
				height: 10px;
			}
			#progressBar {
				width: 0%;
				height: 100%;
				background-color: #007bff;
				transition: width 0.2s ease-out;
			}
			#summaryTableContainer {
				margin-top: 1.5rem;
				overflow-x: auto;
			}
			#summaryTableContainer table {
				/* width: auto; */
				margin: 0 auto;
				border: 1px solid #007bff;
			}
			#summaryTableContainer th,
			#summaryTableContainer td {
				padding: 0.7rem 0.6rem;
				border: 1px solid #bce0fd;
			}
			#summaryTableContainer th {
				background-color: #e7f5ff;
				color: #004085;
				font-weight: 600;
			}
			#summaryTableContainer td.total-amount-value {
				font-weight: bold;
				font-size: 1.2em;
				color: #155724;
				background-color: #d4edda;
			}
			#summaryTableContainer td {
				background-color: #f8f9fa;
			}
			.hidden {
				display: none !important;
			}
		</style>
	</head>
	<body>
		<div class="container">
			<h2>ATM Slip Data Extractor</h2>
			<div class="input-options">
				<label for="fileInput" class="file-input-button">Select File</label>
				<input type="file" id="fileInput" accept="image/*" class="hidden" />
				<button type="button" id="takePhotoBtn">Take Photo</button>
				<input type="file" id="cameraInput" accept="image/*" capture="environment" class="hidden" />
			</div>

			<div id="cropModal" class="crop-modal">
				<div class="crop-modal-content">
					<h3>Crop Image</h3>
					<div id="cropImageContainer">
						<img id="cropPreviewImage" src="#" alt="Crop Preview" />
					</div>
					<div class="crop-actions">
						<button type="button" id="cropButton">Crop & Use</button>
						<button type="button" id="cancelCropButton">Cancel</button>
					</div>
				</div>
			</div>

			<div id="enhancementControls" class="hidden">
				<h3>Adjust Image for OCR</h3>
				<label for="brightnessSlider">Brightness: <span id="brightnessValue">0</span></label>
				<input type="range" id="brightnessSlider" min="-100" max="100" value="0" />
				<label for="contrastSlider">Contrast: <span id="contrastValue">0</span></label>
				<input type="range" id="contrastSlider" min="-100" max="100" value="0" />
				<label for="thresholdSlider">Binarize Threshold: <span id="thresholdValue">0</span> (0 to disable)</label>
				<input type="range" id="thresholdSlider" min="0" max="255" value="0" />
			</div>

			<img id="preview" class="hidden" alt="Enhanced Image preview" />
			<button id="extractBtn" class="hidden">Extract Text</button>

			<div id="progressIndicator" class="hidden">
				<div class="spinner"></div>
				<p id="progressMessage">Initializing...</p>
				<div id="progressBarContainer"><div id="progressBar"></div></div>
			</div>
			<div class="result-table" id="result" class="hidden"></div>
			<div id="summaryTableContainer" class="hidden"></div>
			<pre id="rawText" class="hidden"></pre>
			<button id="downloadBtnMain" class="hidden">Download Excel</button>
			<!-- Changed ID slightly to avoid conflict if global fn name is same -->
		</div>

		<script>
			const DEBUG_MODE = false;

			document.addEventListener("DOMContentLoaded", function () {
				const fileInput = document.getElementById("fileInput");
				const takePhotoBtn = document.getElementById("takePhotoBtn");
				const cameraInput = document.getElementById("cameraInput");
				const preview = document.getElementById("preview");
				const extractBtn = document.getElementById("extractBtn");
				const resultDiv = document.getElementById("result");
				const rawTextPre = document.getElementById("rawText");
				const downloadBtnMain = document.getElementById("downloadBtnMain"); // Matched new ID
				const progressIndicator = document.getElementById("progressIndicator");
				const progressMessage = document.getElementById("progressMessage");
				const progressBar = document.getElementById("progressBar");
				const summaryTableContainer = document.getElementById("summaryTableContainer");
				const cropModal = document.getElementById("cropModal");
				const cropPreviewImage = document.getElementById("cropPreviewImage");
				const cropButton = document.getElementById("cropButton");
				const cancelCropButton = document.getElementById("cancelCropButton");
				const enhancementControlsDiv = document.getElementById("enhancementControls");
				const brightnessSlider = document.getElementById("brightnessSlider");
				const contrastSlider = document.getElementById("contrastSlider");
				const thresholdSlider = document.getElementById("thresholdSlider");
				const brightnessValueSpan = document.getElementById("brightnessValue");
				const contrastValueSpan = document.getElementById("contrastValue");
				const thresholdValueSpan = document.getElementById("thresholdValue");

				let cropperInstance = null;
				let originalCroppedImageSrc = null;
				let imageBeingEnhanced = new Image();
				let extractedData = {};
				let typeValidity = [true, true, true, true];
				const PREPROCESS_MAX_WIDTH_FINAL = 1500;

				fileInput.addEventListener("change", handleFileSelect);
				takePhotoBtn.addEventListener("click", () => cameraInput.click());
				cameraInput.addEventListener("change", handleFileSelect);
				extractBtn.addEventListener("click", extractTextFromPreviewedImage);
				downloadBtnMain.addEventListener("click", downloadExcel); // Using event listener for download button

				brightnessSlider.addEventListener("input", () => {
					brightnessValueSpan.textContent = brightnessSlider.value;
					applyImageEnhancements();
				});
				contrastSlider.addEventListener("input", () => {
					contrastValueSpan.textContent = contrastSlider.value;
					applyImageEnhancements();
				});
				thresholdSlider.addEventListener("input", () => {
					thresholdValueSpan.textContent = thresholdSlider.value;
					applyImageEnhancements();
				});

				function handleFileSelect(event) {
					const file = event.target.files[0];
					if (file) {
						clearAll();
						const reader = new FileReader();
						reader.onload = (e) => {
							cropPreviewImage.src = e.target.result;
							cropModal.style.display = "flex";
							if (cropperInstance) cropperInstance.destroy();
							cropperInstance = new Cropper(cropPreviewImage, { aspectRatio: NaN, viewMode: 1, background: false, autoCropArea: 0.85, responsive: true, checkCrossOrigin: false });
							if (DEBUG_MODE) debugAlert("Cropper initialized. Adjust and click 'Crop & Use'.");
						};
						reader.readAsDataURL(file);
					}
					event.target.value = null;
				}

				cancelCropButton.addEventListener("click", () => {
					cropModal.style.display = "none";
					if (cropperInstance) cropperInstance.destroy();
					cropperInstance = null;
					clearAll();
				});

				cropButton.addEventListener("click", () => {
					if (cropperInstance) {
						originalCroppedImageSrc = cropperInstance.getCroppedCanvas().toDataURL("image/png");
						cropperInstance.destroy();
						cropperInstance = null;
						cropModal.style.display = "none";

						imageBeingEnhanced.onload = () => {
							applyImageEnhancements();
							enhancementControlsDiv.classList.remove("hidden");
							preview.classList.remove("hidden");
							extractBtn.classList.remove("hidden");
						};
						imageBeingEnhanced.src = originalCroppedImageSrc;
						if (DEBUG_MODE) debugAlert("Image cropped. Adjust enhancement sliders if needed, then Extract.");
					}
				});

				function clearAll() {
					resultDiv.innerHTML = "";
					resultDiv.classList.add("hidden");
					summaryTableContainer.innerHTML = "";
					summaryTableContainer.classList.add("hidden");
					rawTextPre.textContent = "";
					rawTextPre.classList.add("hidden");
					downloadBtnMain.classList.add("hidden");
					progressIndicator.classList.add("hidden");
					enhancementControlsDiv.classList.add("hidden");
					preview.classList.add("hidden");
					preview.src = "#";
					extractBtn.classList.add("hidden");

					originalCroppedImageSrc = null;
					brightnessSlider.value = 0;
					brightnessValueSpan.textContent = "0";
					contrastSlider.value = 0;
					contrastValueSpan.textContent = "0";
					thresholdSlider.value = 0;
					thresholdValueSpan.textContent = "0";
				}

				function applyImageEnhancements() {
					if (!originalCroppedImageSrc || !imageBeingEnhanced.src || !imageBeingEnhanced.complete || imageBeingEnhanced.naturalWidth === 0) {
						// If originalCroppedImageSrc is set, but imageBeingEnhanced isn't fully loaded yet,
						// try loading it again just in case. This can happen if sliders are moved too fast.
						if (originalCroppedImageSrc && (!imageBeingEnhanced.src || imageBeingEnhanced.src !== originalCroppedImageSrc)) {
							imageBeingEnhanced.onload = applyImageEnhancements; // Call self once loaded
							imageBeingEnhanced.src = originalCroppedImageSrc;
						}
						return;
					}

					const canvas = document.createElement("canvas");
					canvas.width = imageBeingEnhanced.naturalWidth;
					canvas.height = imageBeingEnhanced.naturalHeight;
					const ctx = canvas.getContext("2d");
					ctx.drawImage(imageBeingEnhanced, 0, 0);

					const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
					const data = imageData.data;
					const brightness = parseInt(brightnessSlider.value);
					const contrast = parseInt(contrastSlider.value);
					const threshold = parseInt(thresholdSlider.value);
					const contrastFactor = contrast / 100 + 1;

					for (let i = 0; i < data.length; i += 4) {
						let r = data[i],
							g = data[i + 1],
							b = data[i + 2];
						let gray = 0.299 * r + 0.587 * g + 0.114 * b;
						gray += brightness;
						gray = contrastFactor * (gray - 128) + 128;
						gray = Math.max(0, Math.min(255, gray));
						if (threshold > 0) {
							gray = gray < threshold ? 0 : 255;
						}
						data[i] = data[i + 1] = data[i + 2] = gray;
					}
					ctx.putImageData(imageData, 0, 0);
					preview.src = canvas.toDataURL("image/png");
				}

				async function finalImagePreprocessBeforeOcr(imageDataUrl, maxWidth) {
					return new Promise((resolve, reject) => {
						const img = new Image();
						img.onload = () => {
							let width = img.width;
							let height = img.height;
							if (width > maxWidth) {
								height = Math.round((height * maxWidth) / width);
								width = maxWidth;
								const canvas = document.createElement("canvas");
								canvas.width = width;
								canvas.height = height;
								const ctx = canvas.getContext("2d");
								ctx.drawImage(img, 0, 0, width, height);
								if (DEBUG_MODE) debugAlert(`Final OCR image resized to ${width}x${height}`);
								resolve(canvas.toDataURL("image/png"));
								return;
							}
							if (DEBUG_MODE) debugAlert(`Final OCR image dimensions: ${width}x${height} (no resize)`);
							resolve(imageDataUrl);
						};
						img.onerror = (err) => reject(new Error("Image load failed for final OCR preprocess."));
						img.src = imageDataUrl;
					});
				}

				async function extractTextFromPreviewedImage() {
					if (!preview.src || preview.src.endsWith("#") || preview.src === "") {
						alert("Please select, crop, and enhance an image first.");
						return;
					}

					extractBtn.disabled = true;
					resultDiv.innerHTML = "";
					resultDiv.classList.add("hidden");
					summaryTableContainer.innerHTML = "";
					summaryTableContainer.classList.add("hidden");
					rawTextPre.textContent = "";
					rawTextPre.classList.add("hidden");
					downloadBtnMain.classList.add("hidden");

					progressIndicator.classList.remove("hidden");
					progressMessage.textContent = "Finalizing image for OCR...";
					progressBar.style.width = "0%";

					try {
						const imageForTesseract = await finalImagePreprocessBeforeOcr(preview.src, PREPROCESS_MAX_WIDTH_FINAL);

						if (DEBUG_MODE) {
							const tempImg = new Image(); // For debug alert only
							tempImg.onload = () => debugAlert(`Image going to Tesseract: ${tempImg.width}x${tempImg.height}`);
							tempImg.onerror = () => debugAlert(`Failed to load image for Tesseract debug info.`);
							tempImg.src = imageForTesseract;
						}

						progressMessage.textContent = "Initializing Tesseract...";
						const result = await Tesseract.recognize(imageForTesseract, "eng", {
							logger: (m) => {
								if (m.status) {
									let s = m.status.replace(/_/g, " ").replace(/\b\w/g, (l) => l.toUpperCase());
									progressMessage.textContent = `${s}...`;
								}
								if (m.progress !== undefined && m.status === "recognizing text") {
									progressBar.style.width = m.progress * 100 + "%";
								} else if (m.progress !== undefined) {
									let s = m.status.replace(/_/g, " ").replace(/\b\w/g, (l) => l.toUpperCase());
									progressMessage.textContent = `${s} (${Math.round(m.progress * 100)}%)...`;
								}
							},
						});

						const text = result.data.text;
						if (DEBUG_MODE) debugAlert("OCR Raw Output (first 200 chars):\n" + text.substring(0, 200) + (text.length > 200 ? "..." : ""));

						extractedData = parseData(text);
						performGlobalValidation(extractedData);
						rawTextPre.textContent = text;
						rawTextPre.classList.remove("hidden");
						showEditableTable(extractedData);
						resultDiv.classList.remove("hidden");
						downloadBtnMain.classList.remove("hidden");
						updateSummaryAndTotal();
					} catch (error) {
						console.error("Error during OCR or final preprocessing:", error);
						if (DEBUG_MODE) debugAlert(`Error during OCR: ${error.message || "Unknown error"}`);
						resultDiv.innerHTML = `<p style="color: red; text-align: center;">Error: ${error.message || "Unknown error"}.</p>`;
						resultDiv.classList.remove("hidden");
					} finally {
						extractBtn.disabled = !preview.src || preview.src.endsWith("#") || preview.src === "";
						progressIndicator.classList.add("hidden");
					}
				}

				function debugAlert(message) {
					if (DEBUG_MODE) alert(message);
				}

				function checkTypeColumnValidity(typeIndex, currentData) {
					const cVal = currentData.CASSETTE[typeIndex],
						rVal = currentData.REJECTED[typeIndex],
						remVal = currentData.REMAINING[typeIndex],
						dVal = currentData.DISPENSED[typeIndex],
						totVal = currentData.TOTAL[typeIndex];
					if (remVal === "" || totVal === "") return false;
					const c = parseInt(cVal || 0),
						r = parseInt(rVal || 0),
						rem = parseInt(remVal),
						d = parseInt(dVal || 0),
						tot = parseInt(totVal);
					if (isNaN(rem) || isNaN(tot) || isNaN(c) || isNaN(r) || isNaN(d)) return false;
					return c + r === rem && rem + d === tot;
				}
				function performGlobalValidation(currentData) {
					for (let i = 0; i < 4; i++) typeValidity[i] = checkTypeColumnValidity(i, currentData);
				}

				function updateSummaryAndTotal() {
					const allValid = typeValidity.every((isValid) => isValid);
					summaryTableContainer.innerHTML = "";
					if (allValid && Object.keys(extractedData).length > 0 && extractedData.REMAINING) {
						const r1 = parseInt(extractedData.REMAINING[0] || 0),
							r2 = parseInt(extractedData.REMAINING[1] || 0),
							r3 = parseInt(extractedData.REMAINING[2] || 0),
							r4 = parseInt(extractedData.REMAINING[3] || 0);
						const t1k = r1 + r2,
							t5h = r3,
							t1h = r4;
						const v1k = t1k * 1000,
							v5h = t5h * 500,
							v1h = t1h * 100,
							tc = v1k + v5h + v1h;
						const st = document.createElement("table");
						st.innerHTML = `<thead><tr><th>Denomination</th><th>Remaining Notes</th><th>Value (Tk.)</th></tr></thead><tbody>
                        <tr><td>1000s</td><td>${t1k.toLocaleString("en-IN")}</td><td>${v1k.toLocaleString("en-IN")}</td></tr>
                        <tr><td>500s</td><td>${t5h.toLocaleString("en-IN")}</td><td>${v5h.toLocaleString("en-IN")}</td></tr>
                        <tr><td>100s</td><td>${t1h.toLocaleString("en-IN")}</td><td>${v1h.toLocaleString("en-IN")}</td></tr>
                        <tr><th colspan="2" style="text-align:right;padding-right:10px;">Total Cash Remaining:</th><td class="total-amount-value">Tk.${tc.toLocaleString("en-IN")}</td></tr>
                    </tbody>`;
						summaryTableContainer.appendChild(st);
						summaryTableContainer.classList.remove("hidden");
					} else {
						summaryTableContainer.classList.add("hidden");
					}
				}

				const parseData = (text) => {
					const lines = text
						.split("\n")
						.map((l) => l.trim())
						.filter(Boolean);
					const data = { CASSETTE: ["", "", "", ""], REJECTED: ["", "", "", ""], REMAINING: ["", "", "", ""], DISPENSED: ["", "", "", ""], TOTAL: ["", "", "", ""] };
					const labels = Object.keys(data);
					const lc = {};
					labels.forEach((l) => (lc[l] = 0));
					lines.forEach((line) => {
						labels.forEach((label) => {
							const rgx = new RegExp(`[+=]?${label}\\s+(\\d{3,5})(?:\\s+(\\d{3,5}))?`, "i");
							const m = line.match(rgx);
							if (m) {
								const v1 = m[1] || "",
									v2 = m[2] || "";
								if (lc[label] === 0) {
									data[label][0] = v1;
									data[label][1] = v2;
								} else if (lc[label] === 1) {
									data[label][2] = v1;
									data[label][3] = v2;
								}
								if (lc[label] < 2) lc[label]++;
							}
						});
					});
					return data;
				};

				function generateInputHtml(v, l, di, icov) {
					let ic = "";
					const ie = v === "";
					if (!icov) ic = "col-invalid";
					else if (ie && ["CASSETTE", "REJECTED", "DISPENSED", "REMAINING", "TOTAL"].includes(l)) ic = "field-problem";
					return `<input type="text" class="${ic}" value="${v}" data-label="${l}" data-index="${di}">`;
				}
				function createRow(l, v1, v2, di1, di2) {
					const r = document.createElement("tr");
					r.innerHTML = `<td>${l}</td><td>${generateInputHtml(v1, l, di1, typeValidity[di1])}</td><td>${generateInputHtml(v2, l, di2, typeValidity[di2])}</td>`;
					return r;
				}
				function showEditableTable(cd) {
					const t = document.createElement("table");
					t.innerHTML = "";
					let h1 = t.insertRow();
					h1.innerHTML = "<th>Label</th><th>Type 1 (1000s)</th><th>Type 2 (1000s)</th>";
					Object.keys(cd).forEach((l) => t.appendChild(createRow(l, cd[l][0], cd[l][1], 0, 1)));
					let sp = t.insertRow();
					sp.innerHTML = '<th colspan="3" style="padding:0.3rem;background-color:#fff;border:0;"></th>';
					let h2 = t.insertRow();
					h2.innerHTML = "<th>Label</th><th>Type 3 (500s)</th><th>Type 4 (100s)</th>";
					Object.keys(cd).forEach((l) => t.appendChild(createRow(l, cd[l][2], cd[l][3], 2, 3)));
					resultDiv.innerHTML = "";
					resultDiv.appendChild(t);
				}

				resultDiv.addEventListener("input", function (e) {
					if (e.target.tagName === "INPUT" && e.target.type === "text") {
						const l = e.target.dataset.label,
							di = parseInt(e.target.dataset.index),
							nv = e.target.value;
						if (extractedData[l]) {
							extractedData[l][di] = nv;
							performGlobalValidation(extractedData);
							showEditableTable(extractedData);
							updateSummaryAndTotal();
							const nt = resultDiv.querySelector("table");
							if (nt) {
								const ins = Array.from(nt.querySelectorAll(`input[data-label="${l}"][data-index="${di}"]`));
								if (ins.length > 0) {
									const cp = e.target.selectionStart;
									ins[0].focus();
									ins[0].setSelectionRange(cp, cp);
								}
							}
						}
					}
				});

				function downloadExcel() {
					const te = resultDiv.querySelector("table");
					if (!te) return;
					const dr = Array.from(te.querySelectorAll("tr")).filter((r) => r.cells.length > 1 && r.cells[1].querySelector("input"));
					const hs = ["Label", "Type 1 (1000s)", "Type 2 (1000s)", "Type 3 (500s)", "Type 4 (100s)"];
					const fd = [];
					const nl = Object.keys(extractedData).length;
					if (dr.length !== nl * 2) {
						alert("Excel export error: table mismatch.");
						return;
					}
					for (let i = 0; i < nl; i++) {
						const r12 = dr[i],
							r34 = dr[i + nl],
							l = r12.cells[0].textContent;
						fd.push([l, r12.cells[1].querySelector("input").value, r12.cells[2].querySelector("input").value, r34.cells[1].querySelector("input").value, r34.cells[2].querySelector("input").value]);
					}
					if (typeValidity.every((v) => v) && extractedData.REMAINING) {
						fd.push([], ["Denomination Summary"], ["Denomination", "Remaining Notes", "Value (Tk.)"]);
						const r1 = parseInt(extractedData.REMAINING[0] || 0),
							r2 = parseInt(extractedData.REMAINING[1] || 0),
							r3 = parseInt(extractedData.REMAINING[2] || 0),
							r4 = parseInt(extractedData.REMAINING[3] || 0);
						const t1k = r1 + r2,
							t5h = r3,
							t1h = r4;
						const v1k = t1k * 1000,
							v5h = t5h * 500,
							v1h = t1h * 100,
							tc = v1k + v5h + v1h;
						fd.push(["1000s", t1k.toLocaleString("en-IN"), v1k.toLocaleString("en-IN")]);
						fd.push(["500s", t5h.toLocaleString("en-IN"), v5h.toLocaleString("en-IN")]);
						fd.push(["100s", t1h.toLocaleString("en-IN"), v1h.toLocaleString("en-IN")]);
						fd.push(["", "Total Cash Remaining:", tc.toLocaleString("en-IN")]);
					}
					const ws = XLSX.utils.aoa_to_sheet([hs, ...fd]);
					const wb = XLSX.utils.book_new();
					XLSX.utils.book_append_sheet(wb, ws, "ATM Slip OCR");
					XLSX.writeFile(wb, "atm_slip_ocr_output.xlsx");
				}
			}); // End of DOMContentLoaded
		</script>
	</body>
</html>
